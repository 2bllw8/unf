package unf.optics.plugin.generator;

import java.util.List;
import java.util.SequencedMap;
import java.util.SequencedSet;
import java.util.Set;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.PrimitiveType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Types;

public abstract class OpticsGenerator {

  protected final Types types;
  protected final TypeMirror targetRecordType;
  protected final SequencedMap<String, TypeMirror> components;
  protected final SequencedSet<String> allComponentNames;

  public OpticsGenerator(
      Types types,
      TypeMirror targetRecordType,
      SequencedMap<String, TypeMirror> components,
      SequencedSet<String> allComponentNames
  ) {
    this.types = types;
    this.targetRecordType = targetRecordType;
    this.components = components;
    this.allComponentNames = allComponentNames;
  }

  /**
   * Generate optics fields and methods.
   */
  public abstract List<String> generate();

  /**
   * Return a set containing the fully qualified names of all types used in the
   * definition and implementation of method and fields generated by this
   * class.
   */
  public abstract Set<String> usedTypes();

  /**
   * Return whether this generator is going to produce something for the given
   * record type.
   */
  public final boolean isProducingSomething() {
    return !components.isEmpty();
  }

  protected final void addTypesToSet(
      TypeMirror tm,
      Set<String> targetSet
  ) {
    if (tm instanceof PrimitiveType) {
      // No need to add primitive types
      return;
    }

    // Add type parameters
    if (tm instanceof DeclaredType dt) {
      for (final TypeMirror paramTm : dt.getTypeArguments()) {
        addTypesToSet(paramTm, targetSet);
      }
    }

    // Add erased type to the set
    targetSet.add(types.erasure(tm).toString());
  }
}
